# Функции

## Статические локальные переменные
```
void FuncCounter() {
  static int counter; // инициализируется один раз за всю программу (по дефолту нулём)
  ++counter;
  std::cout << "Did func " << counter << " times\n";
}

int main() {
  for (int i = 0; i < 4; ++i) {
    FuncCounter();
  }
}
```
## Возврат массивов/указателей/ссылок
```
int[10] Function() { // CE
  int array[10]{};
  return array;
}

int* F() { // при обращении к результату функции будет UB
  int x = 0;
  return &x;
}
int& G() { // аналогично
  int x = 0;
  return x;
}
```
Уже более допустимые варианты:
```
int* CreateArray(int size) { // Какая проблема может нас тут ждать?
    return new int[size];
}

int& Get(int* p) { // А тут?
    return *p;
}

int x = 0;
int* GetPointer() {
    return &x;
}

int& Get() {
    static int x = 0;
    return x;
}
```
Если возвращение идёт по ссылке, то мы получаем доступ к объекту в памяти и можем что-то с ним сделать.
```
int& operator+=(int& x, int y) { // как реализован оператор +=
    x = x + y;
    return x;
}
```

## Перегрузка функций
Перегрузка функций - это механизм, позволяющий заводить функции с одинаковыми именами, но различающиеся списком параметров. (Появился в С++ в отличие от С)
```
int abs(int x);
long abs(long x); // разные типы

int Minus(int x);
int Minus(int x, int y); // разное число параметров
```
Но надо же как-то и выбирать подходящую функцию. Этот процесс называется разрешением перегрузки. И тут уже начинаются сложности.
Во-первых подбираются функции на основании сигнатуры (имя + список параметров), которые удовлетворяют вызову, то есть совпадает название функции, число параметров, существует неявный каст фактических параметров в формальные. Формируется список candidate functions.  \
Упомянутые выше касты делятся на два типа: 
- promotion(расширение) например int -> long -> long long или float -> double
- conversion(преобразование) например float -> long double, double -> long double
[про типы преобразований](https://en.cppreference.com/w/cpp/language/implicit_conversion)

Затем начинается этап overload resolution. На данном этапе выбирается функция, которая требуем наименьшего числа conversion.
```
void F(long double) {
  std::cout << "1\n";
}

void F(double) {
  std::cout << "2\n";
}

int main() {
  float x = 2;
  F(x); // что выведет
}
```

[документация по overload resolution](https://en.cppreference.com/w/cpp/language/overload_resolution)

Небольшое дополнение про `const`: при выборе перегрузки на верхнем уровне игнорируется.

```
void F(int); /* <=> */ void F(const int); -- объявление одной и той же функции
void F(int*); /* <=> */ void F(int* const);
void F(const int*); /* <=> */ void F(const int* const);

void F(int&); /* != */ void F(const int&);
void F(int*); /* != */ void F(const int*);
```

# Рекурсия
Рекурсия - метод решения задач, основанный на решении аналогичной задачи
меньшего размера. Рекурсивная функция - функция, которая вызывает сама себя. Есть два типа рекурсии: прямая рекурсия - ситуация, когда функция вызывает себя непосредственно (напрямую) и косвенная рекурсия, когда функция вызывает себя через вызов
другой (других) функции. Важной частью рекурсивных функций является условие завершения рекурсии. Любой рекурсивный алгоритм можно свести к итеративному. Рекурсия, как правило, более лаконична, но требует больше ресурсов. Рекурсию имеет смысл использовать, если сложность итеративной реализации окупает прирост в производительности. \
Иногда возникает ситуация, например при косвенной рекурсии, когда одна функция использует другую, а та первую:
```
int F(int n) {
  return n <= 1 ? n : 1 + G(n);
}
int G(int n) {
  return n <= 1 ? n : n + F(n - 1);
} // СЕ
```
Как такое решить?

#Сортировки
## Квадратичные сортировки
 Квадратичными называют те сортировки, которые требуют $O(n^2)$ времени
### Сортировка выбором
Суть алгоритма: на каждом i-ом шаге находим i-ый минимальный элемент и меняем его местами с i-ым элементом в массиве. Таким образом будет получен массив, отсортированный по неубыванию.
Дабы немного оптимизировать квадратичное время, можно проходить только по неотсортированному массиву. 
Соответственно выглядеть это будет как-то так:
```
function selectionSort(int[n] a):
   for i = 0 to n - 2
    min = i
     for j = i + 1 to n - 1
       if a[j] < a[min]
         min = j
     swap(a[i], a[min])
```
Количетсво сравнений будет $\frac{n(n − 1)}{2}$
Соответственно алгоритм очевидно работает за $O(n^2)$

### Сортировка вставками
Суть алгоритма: есть часть массива, которая уже отсортирована, и требуется вставить остальные элементы массива в отсортированную часть, сохранив при этом упорядоченность. Для этого на каждом шаге алгоритма мы выбираем один из элементов входных данных и вставляем его на нужную позицию в уже отсортированной части массива, до тех пор пока весь набор входных данных не будет отсортирован. Метод выбора очередного элемента из исходного массива произволен, однако обычно (и с целью получения устойчивого алгоритма сортировки), элементы вставляются по порядку их появления во входном массиве.
```
function insertionSort(int[n] a):
  for i = 1 to n - 1
    j = i - 1
    while j ⩾ 0 and a[j] > a[j + 1] 
      swap(a[j], a[j + 1])
      j--
```

Так как в процессе работы алгоритма могут меняться местами только соседние элементы, каждый обмен уменьшает число инверсий на единицу. Следовательно, количество обменов равно количеству инверсий в исходном массиве вне зависимости от реализации сортировки. Максимальное количество инверсий содержится в массиве, элементы которого отсортированы по невозрастанию. Число инверсий в таком массиве $\frac{n(n − 1)}{2}$.

Алгоритм работает за $O(n + k)$, где k — число обменов элементов входного массива, равное числу инверсий. В среднем и в худшем случае — за $O(n^2)$. Минимальные оценки встречаются в случае уже упорядоченной исходной последовательности элементов, наихудшие — когда они расположены в обратном порядке.

### Сортировка пузырьком
Суть алгоритма состоит в повторяющихся проходах по сортируемому массиву. На каждой итерации последовательно сравниваются соседние элементы, и, если порядок в паре неверный, то элементы меняют местами. За каждый проход по массиву как минимум один элемент встает на свое место, поэтому необходимо совершить не более $n − 1$ проходов, где n размер массива, чтобы отсортировать массив. \
Можно немного оптимизировать алгоритм: во-первых после i-ой итерации внешнего цикла i последних элементов уже находятся на своих местах в отсортированном порядке, поэтому нет необходимости производить их сравнения друг с другом. Следовательно, внутренний цикл можно выполнять не до $n − 2$, а до $n − i − 2$, а во-вторых, если после выполнения внутреннего цикла не произошло ни одного обмена, то массив уже отсортирован, и продолжать что-то делать бессмысленно. Поэтому внутренний цикл можно выполнять не $n − 1$ раз, а до тех пор, пока во внутреннем цикле происходят обмены.
``` 
function bubbleSort(a):
  i = 0
  t = true
  while t
    t = false
    for j = 0 to n - i - 2
      if a[j] > a[j + 1]
        swap(a[j], a[j + 1])
        t = true
    i = i + 1
```
Так как в алгоритме меняться местами могут только соседние элементы, то каждый обмен уменьшает количество инверсий на единицу. Следовательно, количество обменов равно количеству инверсий в исходном массиве вне зависимости от реализации сортировки. Максимальное количество инверсий содержится в массиве, элементы которого отсортированы по убыванию. Несложно посчитать, что количество инверсий в таком массиве $\frac{n(n − 1)}{2}$. Получаем, что $O(n^2)$.
## Линейные сортировки
### Сортировка подсчётом
Удивительно быстрая сортировка, но мало где применимая. \
Описание алгоритма:
Исходная последовательность чисел длины n, с диапазоном чисел от 0 до k, а в конце отсортированная, хранится в массиве A. Также используется вспомогательный массив C с индексами от 0 до k − 1, изначально заполняемый нулями. Последовательно пройдём по массиву A и запишем в C[i] количество чисел, равных i.
Теперь достаточно пройти по массиву C и для каждого $number \in {0,...,k − 1}$ в массив A последовательно записать число C[number] раз.
```
function simpleCountingSort(A: int[n]): 
    for number = 0 to k - 1
        C[number] = 0 
    for i = 0 to n - 1
        C[A[i]] = C[A[i]] + 1;     
    pos = 0;
    for number = 0 to k - 1
        for i = 0 to C[number] - 1
            A[pos] = number;
            pos = pos + 1;
```
Первые два цикла занимают $O(k)$ и $O(n)$ соответственно по времени, а последний $O(n + k)$ итого получается линейная сложность
 
[5 контест](https://contest.yandex.ru/contest/40878/standings)
