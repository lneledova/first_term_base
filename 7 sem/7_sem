

# Шаблоны
Это инструмент, позволяющий написать общую реализацию какой-то функции.
Чтобы написать такую функцию нужно вначале объявить шаблонный параметр:
```
template <class T> или template <typename T>
```
Затем следует сама функция
```
template <class T, class U>
void f(T x, U y);
```
Затем переходим к использованию нашей функции. Нужный тип выводится автоматически по переданным аргументам (при наличии) либо можно указать его(их) напрямую.
```
template <class T>
T Sum(T x, T y) { return x + y; }
Sum(1, 1); // Ok [T == int]
Sum(1, 0.0); // CE

template <class T>
T GetZero() { return 0; }
GetZero<float>(); // Ok [T == float]
```
При передаче аргумента по значению тип T выводится по следующим правилам:
1 CV-квалификаторы ( const , volatile ) игнорируются.
2 Ссылки отбрасываются.
3 Массивы низводятся до указателей.
4 Функции низводятся до указателей на функцию.
5 Типы соответствующие одному шаблонному типу T должны совпадать
(после выполнения всех действий выше).
```
template <class T, class U>
void f(T x, U y);
// Можно вывести оба параметра (если они выводимы)
f(0, 0.0); // Ok: [T=int, U=double]
// Можно явно указать оба
f<double, double>(0, 0.0); // Ok: [T=double, U=double]
// Можно указать первый, второй выведется автоматически (если выводим)
f<float>(0, 0.0); // Ok: [T=float, U=double]
```
При передаче по ссылке или указателю низведений типов не происходит.
```
template <class T>
void f(T& x) { ... }
int x = 0; const int cx = 1; int& rx = x; int arr[10];
f(x); // Ok: void f<int>(int& x);
f(cx); // Ok: void f<const int>(const int& x);
f(rx); // Ok: void f<int>(int& x); нет ссылок на ссылки
f(arr); // Ok: void f<int[10]>(int (&x)[10])
f(0); // CE: нельзя создавать ссылок на временные значения
f<const int>(0); // Ok: void f<const int>(const int&)
// или
template <class T>
void f(const T& x) { ... }
```
## Типы по умолчанию
Также у шаблонов есть типы по умолчанию и можно ссылаться на предыдущие типы:
```
template <typename T = int>
T g() {...}

template <class T, class U = T>
U f(T x) { ... }

f<int, double>(0); // Ok: [T=int, U=double]
f<float>(0); // Ok: [T=float, U=float]
f(0); // Ok: [T=int, U=int]
g() // Ok: [T=int]
```
## Инстанцирование шаблона

Инстанцированием шаблона называется процесс генерации кода. Инстанцирование происходит только по нужде (мы вызываем функцию с каким-то типом). Дабы избежать многократного инстанцирования например при использовании в нескольких файлах можно использовать `template`
```
template <class T>
void f(T x) { ... }

template void f(float);
```

Определение шаблонной функции должно быть видно в файле, в
котором она используется (чтобы ее можно было инстанцировать).
ODR для шаблонов: каждая шаблонная сущность не может быть определена
более чем 1 раз в одной единице трансляции (файле). Причем, если
определения появляются в разных файлах, то они должны быть идентичны.
Короче говоря, определять шаблоны НУЖНО непосредственно в .h файлах.

Также шаблоны можно перегружать как и функции. Тогда правила разрешения перегрузки таковы:
- Точные соответствия всегда побеждают остальные перегрузки.
- Если есть несколько точных соответствий, выиграет соответствие с меньшим числом подстановок и приведений типов.
- При прочих равных обычная функция предпочтительнее шаблона.
Но если очень хочется именно шаблонную реализацию, то можно сделать так:
```
f<>(0, 0);
```

## Специализации шаблонов

Также у шаблонов есть специализации:

```
// общий шаблон
template <class T>
void Sort(T* array, int n) { ... }
// специализация
template <>
void Sort(bool* array, int n) { ... }
```

## Non-type template parameters
В качестве шаблонных параметров помимо типов могут выступать еще и:
- Целые числа
- Указатели
- Ссылки
- std::nullptr_t
- Числа с плавающей точкой (C++20)
- Некоторые классы специального вида (C++20)

```
template <int N, int M>
int Sum() { return N + M; }
Sum<3, 8>(); // Ok: 11
int x = 1;
Sum<1, x>(); // CE (N and M must be compile-time constants!)
template <class T, size_t N>
size_t ArraySize(const T (&array)[N]) { return N; }
int arr[11];
ArraySize(arr); // Ok: 11 (N is deduced from the type of arr)
template <void (*FPtr)(int)>
void Call(int x) { FPtr(x); }
Call<f>(10);
```

# Auto
В наше время(since С++11) `auto` используется для автоматического вывода типа переменной
при инициализации при этом правила вывода типа auto совпадают с правилами вывода для шаблонных
параметров (за некоторым исключением)

```
int x = 0; const int cx = 1; int& rx = x; int arr[10];
auto y = x; // int
auto cy = cx; // int
auto ry = rx; // int
auto arr_y = arr; // int*
auto& z = x; // int&
auto& cz = cx; // const int&
auto& rz = rx; // int&
auto& arr_z = arr; // int(&)[10]
Исключение
auto x = {1, 2, 3}; // std::initializer_list<int>
```
# MergeSort

См конспект ниже.

# Time/Memory limits

При решении задачи важно оценивать, насколько ваше решение подходит под входящие условия и в том числе ограничения на использование времени и памяти. Про время: сейчас почти все компьютеры работают ~$10^9$ частотой (количеством тактов в секунду), а простые операции выполяняются около 1 такта, таким образом оценить время работы вашей программы в секундах можно как: $<количество операций> / <10^8>$ тут степень 8 не просто так появилась, а как раз из-за наших округлений в оценке. Ну а количество операций в алгоритме как раз асимптотикой оценивается, с чем вы уже знакомы. Про память: дополнительная память работает также, размер int это 4 байта, размер памяти вычисляется просто из размера типа и количества элементов. 

[Седьмой контест](https://contest.yandex.ru/contest/41401/problems/)
