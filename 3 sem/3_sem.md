# Выражения/Указатели/Массивы

## Выражения

Категории значения:

Материальная категория значений называется lvalue, не материальная - prvalue.
Так как lvalue значения материальны (соответствуют некоторому расположению в
памяти) они могут быть использованы в качестве левого операнда в операции
присваивания (за некоторыми исключениями, например строковый литерал: "string").

```
int x = 0;
++x; // lvalue 1
x++; // prvalue 1
```

Операции: 
- `sizeof(тип/выражение)` возвращает либо размер типа в байтах либо размер возвращаемого значения. Важно, она не вычисляет значение выражения.
- `static_cast<тип>(выражение)` принудительно осуществляет допустимые неявные преобразования значений одного типа в другой  
- `,` позволяет объединить несколько выражений в одно. Операция гарантирует, что сначала будет вычислено выражение слева. Результатом операции является результат второго операнда (правый операнд).
```
sizeof(char); // 1
int x = 2;
int y = 3;
std:: cout << static_cast<float>(x) / y; // не целочисленное деление
for (int i = 0, int j = 0;; ++i, --j) {};
```

## Указатели
На прошлом семинаре мы упоминали, какие бывают области памяти. *Какие?* \
Сегодня поговорим о динамической.

У объектов в памяти есть адреса, по которым они хранятся. Чтобы его узнать используется операция `&`. *Ко всему ли мы можем применить эту операцию?* \
Соответственно у адресов есть свой тип -- указатель. 
```
int variable = 5;
int* ptr = &variable; // ptr - указатель на int
int** p_ptr = &ptr; // указатель на указатель на int
int variable2 = *ptr; // разыменование указателя, возвращает lvalue

const int x = 0;
const int* px = &x; // либо int const* -- указатель на константу

int y;
int* const py = &y; // константный указатель
int const* const pa = ...; // что это такое? (читаем справа налево)
const float* const** const p = ...; // а такое?

int* p = nullptr; // пустой указатель, можно вместо nullptr писать 0, но не надо
```

### Динамическое выделение памяти
У статической памяти есть ограничения, например, на программу выделяется определённое её количество. \
Это можно решить тем, чтобы использовать динамическую память (ещё называют кучей).
Выражение `new T` создаёт в динамической памяти объект типа T и возвращает его адрес. Соответственно время жизни этого объекта -- до конца выполнения программы. Но память нужно очищать от таких объектов самим. Для этого используется `delete`
```
int* pa = new int; // без инициализации
int* pb = new int(11); // инициализация числом 11
int* pc = new int{13};
int* pf = nullptr;

delete pa;
delete pb;
delete pf; // OK

int* p = new int;
p = nullptr; // потеряли указаль на динамическую память - утечка
new float; // выделили память, указатель не сохранили
p = new int; // забыли удалить после использования - утечка
```

## Массивы
Массив -- это оследовательность элементов одного типа, расположенных непрерывно впамяти, к которым имеется доступ по индексу через некоторый уникальный идентификатор.
```
int array[10]; // 10 - количество элементов, оно должно быть известно на этапе компиляции программы.
array[1]; // операция доступа по индексу
sizeof(array); // 40: возвращает суммарный размер в байтах
sizeof(array) / sizeof(int); // 10: количество элементов
&array; // адрес массива ( int(*)[10] )
```

В большинстве случаев массив ведёт себя как указатель на первый элемент, то есть 
```
int array[4];
int* ptr = array;
std::cout << *ptr; // первый элемент
std::cout << ptr[2] << 2[ptr]; // третий элемент, но не пишите как во втором случае

sizeof(ptr) != sizeof(array) // 4 и 16
&array; // имеет тип int(*)[10]
&ptr; // имеет тип int**

int a[]{1, 2, 3};
int b[]{1, 2, 3};
a == b; // чему это равно?
```
Но как-то всё некруто, что у нас размер массива ограничен. И для этого есть решение: динамические массивы.\
`new[size]` создаёт size объектов в динамической памяти и возвращает указатель на первый элемент.

```
int* array = new int[10]; 
sizeof(new int[10]) == ?

int n = 10;
// Работаем с n ...
int a[n]{1, 2, 3}; // стандартом запрещено, но компиляторы позволяют
int* b = new int[n]{1, 2, 3}; // Ok

// не забываем удалять выделённую память
delete[] array;
```


# И снова сборка!

## Флаги
 На прошлом семинаре мы все разобрались, как собрать и скомпилировать программу на С++. Мы говорили о флаге `-o` сегодня же обсудим ещё несколько полезных флагов.
Werror, Wall, Wextra, а также pedantic

- `-Wall` - выводит большинство предупреждений
- `-Werror` - все warnings заменяет на errors
- `-Wextra` - выводит дополнительно предупреждения, которых нет в `-Wall` 
- `-pedantic` - выводит все предупреждения, требуемые строгими стандартами ISO C++

Можно прочитать [документацию](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html)  по флагам, связанным с warnings

Но флаги это только начало!

## Санитайзеры

В компиляторах есть встроенные санитайзеры, которые могут обнаруживать ошибки в работе с памятью.

Если точнее, есть:
- Undefined Behavior Sanitizer  - может найти undefined-behavior в вашей программе \
Как запустить: `c++ -fsanitize=undefined program.cpp`. После выполнения этой команды программа компилируется с санитайзером и при запуске уже команды (как это сделать?) он подсветит ошибки, которые возникли в run-time. \
Также есть полезный флаг: `-fno-sanitize-recover` который делает abort вашей прграмме при обнаружении ошибки.\
[документация](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)

- AddressSanitizer -  обнаруживает ошибки повреждения памяти, такие как переполнение буфера или доступ к зависшему указателю (использование после освобождения) \
Запуск полностью аналогичен с точностью до:  `-fsanitize=address`

- LeakSanitizer - интегрирован в AddressSanitizer занимается памятью в куче. \
`fsanitize=leak` либо `c++ -fsanitize=address -g memory-leak.c ; ASAN_OPTIONS=detect_leaks=1 ./a.out`
