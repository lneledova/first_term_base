# Ссылки

Ссылка - алтернативное имя объекта в памяти. Соответственно ссылка связана с облатью памяти.
```
int var = 0
int& rvar = var;
std::cout << rvar; // 0
++rvar;
std::cout << rvar << ' ' << var; // 1 1
int& const crvar = var; // CE
int& rlval = 0; // CE
```
Ссылка связывается с областью памяти, поэтому она является константной. \
Что нельзя:
- ссылке присвоить lvalue(тут ведь нет области памяти)
- создать ссылку на `void`
- создать ссылку на ссылку
- создать ссылку без инициализации
- создавать массивы ссылок
```
int& rx; // CE
int& array[2]{x, y}; // СЕ
```
А можно создать ссылку на константу. У такой ссылки соответственно есть права только на чтение:
```
int x = 0
const int cx = 1;
const int& rx = x; // Ok
const int& rcx = cx; // Ok
int& rx = cx; // CE - логично, так как у нас константа, но ссылку мы менять зачем-то хотим раз не добавили const
```
Также константные ссылки продлевают время жизни временного объекта до времени жизни ссылки. Поэтому они могут ссылаться на lvalue и даже дадут ему место в памяти:
```
const int& cx = 0; // а так можно
const int* p = &cx; // Ok
const int& rcx = cx; // Ok
```

# Функции
Функция - элемент программы, связывающий последовательность инструкций с идентификатором(именем) и списком параметров. 
```
ReturnType Name(Type1 p1, Type2 p2, ...) {
// тело функции
} // общий вид объявления функции

std::cout << Name(p1, p2, ...) << '\n'; // вызов функции
```
Объявление функции и определение можно разносить. Также объявить функцию можно несколько раз, но определение должно быть строго одно: One Definition Rule.
```
int Max(int x, int y);
int Max(int, int);
int Max(int, int y);

int Max(int a, int b) { // формальные параметры функции
  return a > b ? a : b;
}

int main() {
    int x = 1;
    int y = 3;
    std::cout << Max(x, y); // фактические
}
```

 Параметры при передаче в функцию копируются в формальные. Также есть параметры по умолчанию, но они должны всегда стоять после остальных. Для того, чтобы работать непосредственно с переменными, переданными в функцию и менять их можно передавать по указателю или по ссылке(в том числе по константной, чтобы гарантировать неизменяемость и чтобы не заниматься излишним копированием, что актуально для тяжеловесных типов)
 ```
 int Max(int x, int y = 0); // OK
 int Max(int x = 0, int y); // CE

 int Max(int, int = 0); // так тоже можно
 int Max(int, int);

void Swap(int* px, int* py) { // принимаем адреса int'ов
    int tmp = *px;
    *px = *py; // меняем значение по адресу px
    *py = tmp; // меняем значение по адресу py
}

void Swap(int& x, int& y) { // принимаем ссылки
    int tmp = x;
    x = y; // меняем значение, на которое ссылается x
    y = tmp; // меняем значение, на которое ссылается y
}

int Max(const int& x, const int& y) {
    return x > y ? x : y;
}
```
Как передать массив?
```
void f(int array[50]); // <=> void f(int* array) // каст к указателю
void f(int (*array_ptr)[50]); // указатель на массив
void f(int (&array_ref)[50]); // ссылка на массив
int Max(const int* array, int size); // самый простой способ: указатель на первый элемент + размер
```

Тип возвращаемого значения указывается перед именем функции, возвращается значение с помощью оператора `return` и при необходимости он может скастовать значение до нужного типа (если это допустимо). `return-ов` может быть несколько внутри функции и после вызова `return` далее функция не выполняется. Можно также не написать `return` но тогда обращение к значению, которое возвращает функция, вызовет UB.

```
int F() { return 0; }
int G() { return 1.0; } // 1 преобразуется в 1
int H() { return "Hello"; } // Ошибка: строка не преобразуется в int

int Max(int a, int b) {
    if (a > b) {
        return a;
    }
    return b;
}

int Max(int x, int y) {
    if (x > 0) {
        return x > y ? x : y;
    }
}
int main() {
    Max(-1, -1); // Ok
    std::cout << Max(-1, -1); // UB
}

void Print(int x) { // функция ничего не возращает на что указывает void
    if (x < 0) return;
    std::cout << x << '\n';
}
```
С введением новых инструментов, также появились и новые требования к кодстайлу: во-первых напоминаю, что названия функций начинаются с заглавной буквы и используем CamelCase, во-вторых декомпозируем код и перестаём всё писать в main.
# Бинарный поиск!

Бинарный(двоичный) поиск - алгоритм поиска объекта по заданному признаку в множестве объектов, упорядоченных по тому же самому признаку, работающий за логарифмическое время.

Двоичный поиск заключается в том, что на каждом шаге множество объектов делится на две части и в работе остаётся та часть множества, где находится искомый объект. Или же, в зависимости от постановки задачи, мы можем остановить процесс, когда мы получим первый или же последний индекс вхождения элемента. Последнее условие — это левосторонний/правосторонний двоичный поиск.

 Если записать последнее условие формулами, то будет так:
- Правосторонний ищет max{i $\in$ [-1, n - 1]: a[i] <= x} 
- Левый ищет min{i $\in$ [0, n]: a[i] >= x}

[Ура, четвёртый контест](https://contest.yandex.ru/contest/40711/standings)

# Полезные вещи для контеста
## НОД(GCD - greatest common divisor): алгоритм Евклида
Идея: gcd(a, b) = (b == 0 : a ? gcd(b, a % b))

Почему работает?

Во-первых после каждой итерации алгоритма переменные строго уменьшаются, поэтому цикл конечен. Теперь покажем, почему gcd(a, b) = gcd(b, a % b). Вначале покажем, что правая часть делится на левую, затем наоборот.
```
Пусть d = gcd(a, b).
a = p * b + r // r = a % b
a % d = 0, b % d = 0 => r % d = 0 (из выражения выше) а если и b делится на d и r(== a % b) следовательно и их gcd.
Обратно аналогично.
```
Асимптотика данного алгоритма O(log min(a, b)). Доказательство данного факта очень большое, но можете погуглить :) \
Интересный факт: a * b = НОД(a, b) * НОК(a, b)
## Магические ускоряющие строки
Вскоре вы столкнётесь с TL (если ещё не столкнулись), иногда их можно решить, вставив данные строки в начале main:
```
std::ios_base::sync_with_stdio(false); //  отключает синхронизацию выводов/вводов от с++ и от с
std::cin.tie(nullptr); // отвязывает поток ввода от потока вывода (по умолчанию std::cout)
std::cout.tie(nullptr); // аналогично
```

```
#include <iostream>
#include <cstdio>
 
int main() {
    std::ios::sync_with_stdio(false);
    std::cout << "a\n";
    std::printf("b\n");
    std::cout << "c\n";
} // может вывести b a c
```
## Комментарий к задаче J
*Как ввести строку?*
В данной задаче можно использовать цикл для ввода массива char:
```
char symb;
while(std::cin >> symb) {...}
```
 Кажется, что цикл может крутится вечно, но есть команда завершения ввода c консоли(а-ля конец файла): Ctrl+D
